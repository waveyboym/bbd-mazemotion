<!DOCTYPE html>
<html>
  <head>
    <title>Maze Motion | Lobby </title>
    <link rel="stylesheet" href="../style/style.css" />
  </head>
  <body>
    <header>
    </header>
    <h1>Lobby</h1>
    <div id="roomId"></div>
    <br>
    <div id="activity"></div>
    <br>
    <div id="status"></div>
    <br>
    <div id="players"></div>
    <br>
    <div id="controls">
      <button id="startGame">Start Game</button>
    </div>
    <button id="fullscreenBtn">Toggle Fullscreen</button>
    <button id="pauseButton">Pause</button>
    <span id="timer">Time: 00:00</span>
    <div id="game">
      <div id="pauseGameModal" class="modal">
        <div class="modal-content">
          <h2>Game Paused</h2>
          <button id="resumeButton">Resume Game</button>
        </div>
      </div>
      <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>
    <button id="back">&lt;-</button>
    <script src="/socket.io/socket.io.js"></script>

    <script>
      const GamingCanvas = document.getElementById('gameCanvas');
 
        const ctx = GamingCanvas.getContext('2d');

        const cellSize = 20;
        const rows = GamingCanvas.width / cellSize;
        const cols = GamingCanvas.height / cellSize;
        let maze = createMaze(rows, cols);

        // Ball variables
        let ballX = 0.5;
        let ballY = 0.5;
        let ballVelX = 0;
        let ballVelY = 0;
        const ballSize = cellSize / 4; // Radius of the ball
        const acceleration = 0.005;
        const maxSpeed = 0.25;
        const friction = 0.95;

        function createMaze(rows, cols) {
        // create maze grid and potential edges
        let maze = [];
        let edges = [];

        for (let i = 0; i < rows; i++) {
            let row = [];
            for (let j = 0; j < cols; j++) {
            row.push({ parent: null, north: true, south: true, east: true, west: true });
            // add all possible edges
            if (i > 0) edges.push({ u: { x: i, y: j }, v: { x: i - 1, y: j } }); // north
            if (j > 0) edges.push({ u: { x: i, y: j }, v: { x: i, y: j - 1 } }); // west
            }
            maze.push(row);
        }

        edges = shuffle(edges);
        
        function find(node) {
        if (node.parent === null) return node;
        return find(node.parent);
    }

    function union(u, v) {
      let rootU = find(u);
      let rootV = find(v);
      if (rootU !== rootV) {
        rootU.parent = rootV;
        return true;
      }
      return false;
    }

// Kruskal's algo
    for (let edge of edges) {
      let u = maze[edge.u.x][edge.u.y];
      let v = maze[edge.v.x][edge.v.y];
      if (union(u, v)) {
        // Remove wall between u and v
        if (edge.u.x > edge.v.x) {
          u.north = false;
          v.south = false;
        } else if (edge.u.x < edge.v.x) {
          v.north = false;
          u.south = false;
        } else if (edge.u.y > edge.v.y) {
          u.west = false;
          v.east = false;
        } else if (edge.u.y < edge.v.y) {
          v.west = false;
          u.east = false;
        }
      }
    }

    return maze;
    }
    

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function drawMaze(maze) {
      ctx.fillStyle = '#fffffff';
      ctx.fillRect(0, 0, GamingCanvas.width, GamingCanvas.height); // Clear canvas

      // Draw the ball
      ctx.fillStyle = 'white';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(ballX * cellSize, ballY * cellSize, ballSize, 0, Math.PI * 2);
      ctx.fill();

      // Draw maze walls
      for (let x = 0; x < rows; x++) {
          for (let y = 0; y < cols; y++) {
          let cell = maze[x][y];
          let startX = y * cellSize;
          let startY = x * cellSize;

          ctx.beginPath();
          if (cell.north) ctx.moveTo(startX, startY), ctx.lineTo(startX + cellSize, startY);
          if (cell.south) ctx.moveTo(startX, startY + cellSize), ctx.lineTo(startX + cellSize, startY + cellSize);
          if (cell.east) ctx.moveTo(startX + cellSize, startY), ctx.lineTo(startX + cellSize, startY + cellSize);
          if (cell.west) ctx.moveTo(startX, startY), ctx.lineTo(startX, startY + cellSize);
          ctx.stroke();
          }
      }
    }

    function updateBallPosition() {

  let newBallX = ballX + ballVelX;
  let newBallY = ballY + ballVelY;

  let x = 0;
  let y = 0;

  if (ballVelX > 0) {
      x = ballSize / cellSize;
  } else if (ballVelX < 0) {
      x = -ballSize / cellSize;
  }

  if (ballVelY > 0) {
      y = ballSize / cellSize;
  } else if (ballVelY < 0) {
      y = -ballSize / cellSize;
  }

  // Check for collisions with walls
  let currentCellX = Math.floor(ballX);
  let currentCellY = Math.floor(ballY);
  let nextCellX = Math.floor(newBallX + x);
  let nextCellY = Math.floor(newBallY + y);

  if (currentCellX !== nextCellX) {
      if (ballVelX > 0 && maze[currentCellY][currentCellX].east) {
      newBallX = currentCellX + 1 - ballSize / cellSize;
      ballVelX = 0;
      } else if (ballVelX < 0 && maze[currentCellY][currentCellX].west) {
      newBallX = currentCellX + ballSize / cellSize;
      ballVelX = 0;
      }
  }

  if (currentCellY !== nextCellY) {
      if (ballVelY > 0 && maze[currentCellY][currentCellX].south) {
      newBallY = currentCellY + 1 - ballSize / cellSize;
      ballVelY = 0;
      } else if (ballVelY < 0 && maze[currentCellY][currentCellX].north) {
      newBallY = currentCellY + ballSize / cellSize;
      ballVelY = 0;
      }
  }

  ballX = newBallX;
  ballY = newBallY;

  drawMaze(maze);
  }

      let keysPressed = {};
      document.addEventListener('keydown', (event) => {
      keysPressed[event.key] = true;
      });
      document.addEventListener('keyup', (event) => {
      keysPressed[event.key] = false;
      });

      window.addEventListener('deviceorientation', handleOrientation);

      function handleOrientation(event) {
          const y_val = event.beta;  // Tilt front-to-back
          const z_val = event.gamma; // Tilt left-to-right
          canvas.style.transform = `rotateY(${event.gamma/2}deg) rotateX(${-event.beta/2}deg)`;

          // Adjust ball velocity based on device orientation
          ballVelY = Math.max(Math.min(y_val / 90 * maxSpeed, maxSpeed), -maxSpeed);
          ballVelX = Math.max(Math.min(z_val / 90 * maxSpeed, maxSpeed), -maxSpeed);
      }

      function gameLoop() {
          if (keysPressed['ArrowUp']) {
              ballVelY = Math.max(ballVelY - acceleration, -maxSpeed);
            } else if (keysPressed['ArrowDown']) {
              ballVelY = Math.min(ballVelY + acceleration, maxSpeed);
            } else {
              ballVelY *= friction; // Deceleration
            }
            if (keysPressed['ArrowLeft']) {
              ballVelX = Math.max(ballVelX - acceleration, -maxSpeed);
            } else if (keysPressed['ArrowRight']) {
              ballVelX = Math.min(ballVelX + acceleration, maxSpeed);
            } else {
              ballVelX *= friction; // Deceleration
          }
          updateBallPosition();
          requestAnimationFrame(gameLoop);
      }

      drawMaze(maze);
      console.log("Maze array:", maze);
      gameLoop();
    

      const socket = io();
      const roomId = window.location.pathname.split("/").pop();
      document.getElementById("roomId").innerText = `Lobby ID -> ${roomId}`;

      document.getElementById("startGame").onclick = () => {
        socket.emit("startGame", roomId);
        startTimer();
      };

      document.getElementById('back').addEventListener('click', function() {
        window.location.href = '/'; 
      });

      socket.emit("joinRoom", roomId);

      socket.on("roomJoined", (data) => {
        document.getElementById(
          "activity"
        ).innerText = `Share this room ID -> ${data.roomId}`;
      });

      socket.on("roomNotFound", () => {
        const statusElement = document.getElementById("status");
        statusElement.innerText = `Room not found. Join an existing room or create a new room.`;
        statusElement.style.color = "red"; 
        document.getElementById("startGame").style.display = "none";
        document.getElementById("pauseButton").style.display = "none";
        document.getElementById("timer").style.display = "none";
      });

      socket.on("roomFull", () => {
        document.getElementById("status").innerText = `Room is full`;
      });

      socket.on("playersInRoom", (data) => {
        document.getElementById(
          "players"
        ).innerText = `Current Lobby -> ${data.Users.map((user) => {
          return user.id;
        }).join(", ")}`;
      });

      socket.on("gameReady", () => {
        const statusElement = document.getElementById("status");
        statusElement.innerText = `Game ready to start!`;
        statusElement.style.color = "green";
        document.getElementById("startGame").style.display = "block";
        document.getElementById("pauseButton").style.display = "none";
        document.getElementById("timer").style.display = "none";
      });

      socket.on("gameNotReady", () => {
        const statusElement = document.getElementById("status");
        statusElement.innerText = `Not enough players to start the game.`;
        statusElement.style.color = "red";
        document.getElementById("startGame").style.display = "none";
        document.getElementById("pauseButton").style.display = "none";
        document.getElementById("timer").style.display = "none";
      });

      socket.on("gameStarted", (data) => {
        document.getElementById("status").innerText = `Game started!`;
        document.getElementById("startGame").style.display = "none";
        document.getElementById("pauseButton").style.display = "inline";
        document.getElementById("timer").style.display = "inline";
        console.log(data);
      });

      socket.on('updatePositions', (data) => {
            // {Users: [{id: 'player1', position: { x: 0, y: 0 }}, {id: 'player2', position: { x: 0, y: 0 }}]}
            console.log(data);
      });

      document.addEventListener("DOMContentLoaded", function () {
        const modal = document.getElementById("startGameModal");
        const enterButton = document.getElementById("enterButton");


        if (modal && enterButton) {
          modal.style.display = "block";

          enterButton.addEventListener("click", function () {
            modal.style.display = "none"; 
          });
        } else {
          console.error("Modal or Start Button not found.");
        }
      });

      document.addEventListener("DOMContentLoaded", (event) => {
        const pauseButton = document.getElementById("pauseButton");
        const resumeButton = document.getElementById("resumeButton");
        const pauseGameModal = document.getElementById("pauseGameModal");

        pauseButton.addEventListener("click", () => {
          pauseGameModal.style.display = "flex";
        });

        resumeButton.addEventListener("click", () => {
          pauseGameModal.style.display = "none";
        });
      });

      document.getElementById('fullscreenBtn').addEventListener('click', function() {
        const canvas = document.getElementById('gameCanvas');
        const requestFullscreen = canvas.requestFullscreen || canvas.mozRequestFullScreen || canvas.webkitRequestFullscreen || canvas.msRequestFullscreen;
        const exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen;

        if (!document.fullscreenElement) {
          requestFullscreen.call(canvas).catch(err => {
            alert("Fullscreen mode failed to activate. Make sure you're using a compatible browser and your site is served over HTTPS.");
            console.error("Error attempting to enable fullscreen mode:", err.message);
          });
        } else {
          exitFullscreen.call(document).catch(err => {
            alert("Failed to exit fullscreen mode.");
            console.error("Error attempting to disable fullscreen mode:", err.message);
          });
        }
      });

      let timerInterval;
      let totalSeconds = 0;
      let isPaused = false;

      function startTimer() {
        totalSeconds = 0;
        timerInterval = setInterval(updateTimer, 1000);
      }

      function updateTimer() {
        if (!isPaused) {
          totalSeconds++;
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          document.getElementById("timer").innerHTML = `Time: ${
            minutes < 10 ? "0" : ""
          }${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
        }
      }

      function pauseTimer() {
        isPaused = true;
      }

      function resumeTimer() {
        isPaused = false;
      }

      document
        .getElementById("enterButton")
        .addEventListener("click", function () {
          document.getElementById("startGameModal").style.display = "none";

        });

      document
        .getElementById("pauseButton")
        .addEventListener("click", function () {
          isPaused = !isPaused;
          if (isPaused) {
            pauseTimer();
          } else {
            resumeTimer();
          }
        });

    </script>
  </body>
</html>
